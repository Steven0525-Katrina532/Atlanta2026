import * as functions from "firebase-functions";
import * as admin from "firebase-admin";

if (!admin.apps.length) admin.initializeApp();

function isPrivileged(claims: any): boolean {
  return claims?.role === "supervisor" || claims?.role === "admin";
}
function requirePrivileged(context: functions.https.CallableContext) {
  if (!context.auth) throw new functions.https.HttpsError("unauthenticated", "Sign in required");
  const claims = context.auth.token as any;
  if (!isPrivileged(claims)) throw new functions.https.HttpsError("permission-denied", "Supervisor or Admin required");
}
function requireAdmin(context: functions.https.CallableContext) {
  if (!context.auth) throw new functions.https.HttpsError("unauthenticated", "Sign in required");
  const claims = context.auth.token as any;
  if (claims?.role !== "admin") throw new functions.https.HttpsError("permission-denied", "Admin role required");
}
}

export const setWindow = functions.https.onCall(async (data, context) => {
  requirePrivileged(context);
  const open = !!data?.open;
  const closeAt = data?.closeAt || null; // ISO string or null
  await admin.firestore().doc("settings/window").set({ open, closeAt, updatedAt: admin.firestore.FieldValue.serverTimestamp() }, { merge: true });
  return { ok: true };
});

export const listLateRequests = functions.https.onCall(async (_data, context) => {
  requirePrivileged(context);
  const snap = await admin.firestore().collection("lateRequests").orderBy("createdAt", "desc").limit(200).get();
  const items = snap.docs.map(d => ({ id: d.id, ...d.data() }));
  return { items };
});

export const decideLate = functions.https.onCall(async (data, context) => {
  requirePrivileged(context);
  const id = data?.id;
  const decision = data?.decision; // "approve" | "deny"
  if (!id || !["approve","deny"].includes(decision)) {
    throw new functions.https.HttpsError("invalid-argument", "id and decision required");
  }
  const ref = admin.firestore().collection("lateRequests").doc(id);
  await ref.set({ decision, decidedAt: admin.firestore.FieldValue.serverTimestamp(), decidedBy: context.auth!.uid }, { merge: true });
  return { ok: true };
});

export const runEngine = functions.https.onCall(async (data, context) => {
  requirePrivileged(context);
  const month = data?.month; // "YYYY-MM"
  if (!month) throw new functions.https.HttpsError("invalid-argument", "month required");
  // TODO: implement real engine; for now, audit only
  await admin.firestore().collection("audits").add({
    type: "runEngine",
    month,
    by: context.auth!.uid,
    at: admin.firestore.FieldValue.serverTimestamp()
  });
  return { ok: true };
});

/** ADMIN-ONLY: set a user role (e.g., supervisor/admin/driver) */
export const setUserRole = functions.https.onCall(async (data, context) => {
  requireAdmin(context);
  const email = (data?.email || "").toLowerCase().trim();
  const role  = (data?.role || "").toLowerCase().trim(); // "admin" | "supervisor" | "driver"
  if (!email || !["admin","supervisor","driver"].includes(role)) {
    throw new functions.https.HttpsError("invalid-argument", "email and valid role required");
  }
  const user = await admin.auth().getUserByEmail(email);
  await admin.auth().setCustomUserClaims(user.uid, { role });
  await admin.firestore().collection("audits").add({
    type: "setUserRole", email, role, by: context.auth!.uid,
    at: admin.firestore.FieldValue.serverTimestamp()
  });
  return { ok: true };
});

/** ADMIN-ONLY: export monthly PDF (stubbed; records audit) */
export const exportMonthlyPdf = functions.https.onCall(async (data, context) => {
  requireAdmin(context);
  const month = data?.month;
  if (!month) throw new functions.https.HttpsError("invalid-argument", "month required");
  await admin.firestore().collection("audits").add({
    type: "exportMonthlyPdf", month, by: context.auth!.uid,
    at: admin.firestore.FieldValue.serverTimestamp()
  });
  // TODO: generate PDF & return signed URL
  return { ok: true, url: null };
});
